# $\fbox{ACADEMIC RECORD STORAGE}$





## **Topic - 1: Abstract**

### <u>Overview</u>

Storing in-memory data is a very common practice in areas where information has to be stored in intermediate buffers like servers, when passing data from one node to another. This micro project demonstrates an alternative perspective to address the same issue.


### <u>Problem Statement</u>

***"Academic Record Storage"*** is a micro project to display how **DFA parsers** can be used in exchange of **trie structures** for parsing & storing in-memory data, along with a better performance. In layman's language, it solves the performance issues faced in such areas using hash maps.



## **Topic - 2: Literature Survey**

### <u>Motivation</u>

Parsers has always been a topic of enthusiasm among system programmers. Compilers are integral part of computer science and parsers form the very basis of these, being used for parsing syntaxes & producing output for the user. While there are these needs which are addressed everyday with continuous improvement, it is also an area of fascination for many who are deep into theoretical computer science. This pushes developers to try, experiment & improve the existing processes for the better of the humanity.


### <u>Observed Loopholes</u>

- GUI based applications have measure overhead on boards with limited resources, which a command based interface solves with minimum overhead.
- There are lack of true minimal applications which can address the very same problem faced in resource scarce areas.


### <u>Research Studies</u>

- ***Deterministic finite automata (DFA)*** is an ideal parser for ambiguity free parsing & operation in exchange of large codes to be maintained. DFA work on state transitions as per encountered symbols, which are easy to understand ever for a beginner.
- ***In-memory storage*** on hard drives take about $1\;millisecond$ roughly, while on solid state drives it takes $1\;microsecond$ & $1 nanosecond$ when operation is done on RAM (with GCC).



## **Topic - 3: Tech Stacks & Concepts**

### <u>Programming Language</u>

- ***Python*** for its simplicity in demonstrating concepts & explaining codes.


### <u>Theoretical Concepts</u>

- ***Deterministic finite automata*** for ambiguity-free parsing.
- ***Procedural approach*** instead of **OOPS** for its simplicity for small programs.



## **Topic - 4: Conclusion**

### <u>Complexity Improvement</u>

The tradeoff made is made between time & space complexity, where time complexity is improved to almost $O(1)$ through usage of hash maps, but a compromise is made on the space complexity, where hash maps own ample of resources.


### <u>Conclusion</u>

DFA based command parsers which enforce in-memory storage are best for resource abundant systems where first priority is given to time for better responsiveness. While for environments where memory in specific are limited, using same approach won't give the best result.

---
